<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>NigmaJS - HMM Decryption Tool</title>
    <link rel="stylesheet" href="css/styles.css">
    <link rel="stylesheet" href="css/guesser.css">
    <link rel="stylesheet" href="css/navbar.css">
    <script src="https://cdn.jsdelivr.net/npm/@tensorflow/tfjs@4.15.0/dist/tf.min.js"></script>
</head>
<body>
    <!-- Loading Overlay -->
    <div id="loading-overlay">
        <div class="loader-container">
            <div class="spinner"></div>
            <div class="loading-text">Initializing NigmaJS...</div>
        </div>
    </div>

    <!-- Navbar injected by navbar.js -->
    <div class="container">
        <header class="guesser-header">
            <h1>üîì Universal Decryption Tool <span style="font-size: 0.5em; vertical-align: middle; background: #f59e0b; color: #000; padding: 2px 8px; border-radius: 4px; margin-left: 10px;">EXPERIMENTAL</span></h1>
            <p class="subtitle">Automated cryptanalysis sandbox. Work in progress.</p>
        </header>

        <!-- Disclaimer / Limitations -->
        <div class="input-card" style="border-left: 4px solid #f59e0b; background: rgba(245, 158, 11, 0.05);">
            <h3 style="color: #f59e0b; margin-top: 0;">‚ö†Ô∏è Early Development Stage</h3>
            <p style="font-size: 0.9rem; margin-bottom: 0;">
                This tool is currently <strong>experimental</strong> and may fail often. Automated decryption is statistical and requires specific conditions to work:
            </p>
            <ul style="font-size: 0.9rem; color: #94a3b8; margin-top: 0.5rem; padding-left: 1.5rem;">
                <li><strong>Text Length:</strong> Requires at least 50-100 characters for accurate statistics.</li>
                <li><strong>Language:</strong> Optimized for standard English. Slang, mixed languages, or numbers will confuse it.</li>
                <li><strong>Supported Ciphers:</strong> Currently targets Caesar, Vigen√®re, and Simple Substitution only.</li>
            </ul>
        </div>

        <div class="input-card">
            <h2>üìù Ciphered Text</h2>
            <textarea id="cipherInput" placeholder="Paste ciphertext here (must be simple substitution)..."></textarea>
            
            <!-- Cipher Type Detection -->
            <div id="cipherDetectionContainer" style="margin-top: 1rem; display: none; padding: 1rem; background: rgba(139, 92, 246, 0.1); border-left: 4px solid #8b5cf6; border-radius: 8px;">
                <h3 style="margin-top: 0; color: #a78bfa; font-size: 1rem;">üîç Cipher Detection</h3>
                <div id="cipherDetectionContent" style="font-size: 0.9rem; color: #e2e8f0;">
                    <!-- Dynamic content will be inserted here -->
                </div>
            </div>

            <div id="progressContainer" style="margin-top: 1rem; display: none;">
                <div style="display: flex; justify-content: space-between; margin-bottom: 0.5rem;">
                    <span style="color: var(--text-muted);">Decrypting...</span>
                    <span id="progressText" style="color: var(--accent);">0%</span>
                </div>
                <div style="width: 100%; height: 8px; background: rgba(255,255,255,0.1); border-radius: 4px; overflow: hidden;">
                    <div id="progressBar" style="width: 0%; height: 100%; background: var(--accent); transition: width 0.2s;"></div>
                </div>
            </div>

            <button id="btnSolve" class="tab-btn active" style="margin-top: 1rem; width: 100%; text-align: center;">
                üöÄ Attempt Decryption
            </button>
        </div>

            <div id="resultsContainer" class="input-card" style="display: none; border-color: var(--success);">
                <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 1rem;">
                    <h2 style="margin: 0;">üîì Decrypted Result (Live Preview)</h2>
                    <span id="methodBadge" style="background: rgba(255,255,255,0.1); padding: 4px 8px; border-radius: 4px; font-size: 0.8rem; color: var(--accent);">
                        Method: HMM
                    </span>
                </div>
                <p id="decryptedOutput" style="font-family: monospace; white-space: pre-wrap; word-wrap: break-word; overflow-wrap: break-word; color: #e2e8f0; font-size: 1.1rem; line-height: 1.6;"></p>
            </div>

            <div class="input-card">
                <h3>How it works</h3>
                <p style="color: #94a3b8; font-size: 0.9rem; line-height: 1.6;">
                    This tool uses an <strong>Intelligent Orchestrator</strong> that automatically detects and attacks classical ciphers:
                    <br><br>
                    <strong>üîç Step 1 - Detection:</strong> Analyzes Index of Coincidence (IC), Entropy, and Kasiski patterns to identify cipher type.
                    <br>
                    <strong>üéØ Step 2 - Strategy Selection:</strong> Chooses the optimal attack based on detection:
                    <ul style="margin: 0.5rem 0 0.5rem 1.5rem; padding: 0;">
                        <li><strong>Caesar/ROT13:</strong> Brute force (26 rotations) with N-gram scoring</li>
                        <li><strong>Vigen√®re:</strong> Friedman Test + frequency analysis per column</li>
                        <li><strong>Substitution:</strong> Hill Climbing or Simulated Annealing with quadgram scoring</li>
                        <li><strong>Advanced Polyalphabetic:</strong> Beaufort, Porta, Gronsfeld, Quagmire (experimental)</li>
                    </ul>
                    <strong>‚ö° Step 3 - Execution:</strong> Runs the selected attack and returns the best result.
                    <br><br>
                    <strong>üìä Powered by:</strong> N-gram models (quadgrams), log-likelihood scoring, and heuristic search algorithms from cryptanalysis research.
                    <br><br>
                    <strong>‚ö†Ô∏è Current Limitations:</strong>
                    <ul style="margin: 0.5rem 0 0 1.5rem; padding: 0; font-size: 0.85rem; color: #f59e0b;">
                        <li><strong>Beaufort:</strong> ~40-60% success rate (requires >200 chars)</li>
                        <li><strong>Porta:</strong> ~60-70% success rate</li>
                        <li><strong>Quagmire:</strong> ~20-30% success rate (very difficult without known alphabet)</li>
                        <li><strong>General:</strong> Longer texts and shorter keys improve accuracy significantly</li>
                    </ul>
                    <br>
                    <em>Note: This is an experimental tool. For production cryptanalysis, combine with manual analysis.</em>
                </p>
            </div>
    </div>

    <script src="js/nigma.min.js"></script>
    <script src="js/navbar.js"></script>
    <script>
        document.addEventListener('DOMContentLoaded', () => {
            // Check Library and Hide Loader
            function checkLibrary() {
                if (window.nigmajs && window.nigmajs.HMMSolver) {
                    const loader = document.getElementById('loading-overlay');
                    if (loader) {
                        loader.classList.add('hidden');
                        setTimeout(() => loader.remove(), 500);
                    }
                } else {
                    setTimeout(checkLibrary, 200);
                }
            }
            checkLibrary();

            const btnSolve = document.getElementById('btnSolve');
            const input = document.getElementById('cipherInput');
            const output = document.getElementById('decryptedOutput');
            const container = document.getElementById('resultsContainer');
            const progressContainer = document.getElementById('progressContainer');
            const progressBar = document.getElementById('progressBar');
            const progressText = document.getElementById('progressText');
            const methodBadge = document.getElementById('methodBadge');
            const cipherDetectionContainer = document.getElementById('cipherDetectionContainer');
            const cipherDetectionContent = document.getElementById('cipherDetectionContent');

            // Helper: Apply decrypted letters back to original layout (preserving spaces/numbers)
            function matchLayout(original, cleanDecrypted) {
                let result = "";
                let cleanIndex = 0;
                for (let i = 0; i < original.length; i++) {
                    const char = original[i];
                    if (char.match(/[a-zA-Z]/)) {
                        // It's a letter, use the decrypted one
                        if (cleanIndex < cleanDecrypted.length) {
                            const decChar = cleanDecrypted[cleanIndex];
                            // Maintain original case
                            result += (char === char.toUpperCase()) ? decChar.toUpperCase() : decChar.toLowerCase();
                            cleanIndex++;
                        } else {
                            result += char; // Fallback
                        }
                    } else {
                        // Not a letter (space, number), keep as is
                        result += char;
                    }
                }
                return result;
            }

            // Helper: Random Char for Matrix Effect
            const randomChar = () => "ABCDEFGHIJKLMNOPQRSTUVWXYZ"[Math.floor(Math.random() * 26)];

            // Cipher Detection on Input Change (with debounce)
            let detectionTimeout;
            input.addEventListener('input', () => {
                clearTimeout(detectionTimeout);
                detectionTimeout = setTimeout(() => {
                    const text = input.value.trim();
                    if (text.length < 20) {
                        cipherDetectionContainer.style.display = 'none';
                        return;
                    }

                    try {
                        const { CipherIdentifier } = window.nigmajs;
                        if (!CipherIdentifier) return;

                        const result = CipherIdentifier.identify(text);
                        
                        // Build HTML for detection results
                        let html = '<div style="display: flex; flex-direction: column; gap: 0.75rem;">';
                        
                        // Stats
                        html += `<div style="display: flex; gap: 1rem; font-size: 0.85rem; color: #94a3b8;">
                            <span><strong>Length:</strong> ${result.stats.length}</span>
                            <span><strong>IC:</strong> ${result.stats.ic}</span>
                            <span><strong>Entropy:</strong> ${result.stats.entropy}</span>
                        </div>`;
                        
                        // Top Candidates
                        html += '<div style="margin-top: 0.5rem;"><strong style="color: #a78bfa;">Probable Cipher Types:</strong></div>';
                        html += '<div style="display: flex; flex-direction: column; gap: 0.5rem; margin-top: 0.5rem;">';
                        
                        result.families.slice(0, 3).forEach((family, index) => {
                            const icon = index === 0 ? 'ü•á' : index === 1 ? 'ü•à' : 'ü•â';
                            const confidencePercent = (family.confidence * 100).toFixed(0);
                            const confidenceColor = family.confidence > 0.7 ? '#10b981' : family.confidence > 0.4 ? '#f59e0b' : '#94a3b8';
                            
                            html += `<div style="display: flex; justify-content: space-between; align-items: center; padding: 0.5rem; background: rgba(255,255,255,0.05); border-radius: 4px;">
                                <div>
                                    <span style="margin-right: 0.5rem;">${icon}</span>
                                    <strong style="color: #e2e8f0;">${family.type.replace(/-/g, ' ').toUpperCase()}</strong>
                                    ${family.suggestedKeyLength ? `<span style="color: #94a3b8; font-size: 0.8rem; margin-left: 0.5rem;">(Key Length: ~${family.suggestedKeyLength})</span>` : ''}
                                </div>
                                <div style="display: flex; align-items: center; gap: 0.5rem;">
                                    <div style="width: 60px; height: 6px; background: rgba(255,255,255,0.1); border-radius: 3px; overflow: hidden;">
                                        <div style="width: ${confidencePercent}%; height: 100%; background: ${confidenceColor};"></div>
                                    </div>
                                    <span style="color: ${confidenceColor}; font-size: 0.85rem; font-weight: bold;">${confidencePercent}%</span>
                                </div>
                            </div>`;
                        });
                        
                        html += '</div></div>';
                        
                        cipherDetectionContent.innerHTML = html;
                        cipherDetectionContainer.style.display = 'block';
                    } catch (e) {
                        console.error('Cipher detection error:', e);
                        cipherDetectionContainer.style.display = 'none';
                    }
                }, 500); // 500ms debounce
            });

            btnSolve.addEventListener('click', async () => {
                const text = input.value;
                if (!text) return;

                btnSolve.innerText = "‚è≥ Solving...";
                btnSolve.disabled = true;
                output.innerText = "";
                container.style.display = 'block'; 
                progressContainer.style.display = 'block';
                methodBadge.innerText = "Method: Detecting...";
                
                // Reset Badge
                methodBadge.style.color = 'var(--accent)';
                methodBadge.style.borderColor = 'var(--border)';

                // Wait for UI update
                setTimeout(async () => {
                    try {
                        const { Orchestrator } = window.nigmajs;
                        if (!Orchestrator) throw new Error("Orchestrator not loaded.");

                        // --- Use Orchestrator with Generator for Progress Tracking ---
                        const orchestrator = new Orchestrator('english');
                        let lastProgress = 0;
                        
                        for await (const status of orchestrator.autoDecryptGenerator(text, {
                            tryMultiple: false // Use first strategy for speed
                        })) {
                            // Update progress based on stage
                            if (status.stage === 'detection') {
                                progressBar.style.width = '10%';
                                progressText.innerText = `Detected: ${status.cipherType}`;
                                methodBadge.innerText = `Cipher: ${status.cipherType.replace(/-/g, ' ').toUpperCase()}`;
                            } else if (status.stage === 'strategy-selection') {
                                progressBar.style.width = '20%';
                                progressText.innerText = `Strategy: ${status.strategy}`;
                                methodBadge.innerText = `Method: ${status.strategy}`;
                            } else if (status.stage === 'solving') {
                                // Show progress with matrix effect
                                const progress = Math.min(status.progress || 20, 95);
                                if (progress > lastProgress + 5) { // Update every 5%
                                    progressBar.style.width = `${progress}%`;
                                    progressText.innerText = `Solving... ${progress.toFixed(0)}%`;
                                    
                                    // Matrix effect on intermediate results
                                    if (status.plaintext) {
                                        let noisyGuess = "";
                                        const cleanText = status.plaintext;
                                        for(let i=0; i<cleanText.length; i++) {
                                            if (Math.random() < 0.15) {
                                                noisyGuess += randomChar();
                                            } else {
                                                noisyGuess += cleanText[i];
                                            }
                                        }
                                        output.innerText = matchLayout(text, noisyGuess);
                                    }
                                    
                                    lastProgress = progress;
                                    await new Promise(r => setTimeout(r, 10));
                                }
                            } else if (status.stage === 'complete') {
                                // Final result
                                progressBar.style.width = '100%';
                                progressText.innerText = 'Done!';
                                progressBar.style.background = "#10b981";
                                
                                output.innerText = matchLayout(text, status.plaintext);
                                
                                // Update badge with method and confidence
                                const confidencePercent = (status.confidence * 100).toFixed(0);
                                methodBadge.innerText = `Method: ${status.method.toUpperCase()} (${confidencePercent}% confidence)`;
                                
                                // Color based on confidence
                                if (status.confidence > 0.7) {
                                    methodBadge.style.color = '#10b981'; // Green
                                    methodBadge.style.borderColor = '#10b981';
                                } else if (status.confidence > 0.4) {
                                    methodBadge.style.color = '#f59e0b'; // Orange
                                    methodBadge.style.borderColor = '#f59e0b';
                                } else {
                                    methodBadge.style.color = '#ef4444'; // Red
                                    methodBadge.style.borderColor = '#ef4444';
                                }
                                
                                container.scrollIntoView({ behavior: 'smooth' });
                            }
                        }

                    } catch (e) {
                        console.error(e);
                        alert("Error: " + e.message);
                        output.innerText = "‚ùå Decryption failed. The cipher may be too complex or the text too short.";
                    } finally {
                        btnSolve.innerText = "üöÄ Attempt Decryption";
                        btnSolve.disabled = false;
                    }
                }, 100);
            });
        });
    </script>
</body>
</html>

