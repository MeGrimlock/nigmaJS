<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>NigmaJS - HMM Decryption Tool</title>
    <link rel="stylesheet" href="css/styles.css">
    <link rel="stylesheet" href="css/guesser.css">
    <link rel="stylesheet" href="css/navbar.css">
    <script src="https://cdn.jsdelivr.net/npm/@tensorflow/tfjs@4.15.0/dist/tf.min.js"></script>
</head>
<body>
    <!-- Loading Overlay -->
    <div id="loading-overlay">
        <div class="loader-container">
            <div class="spinner"></div>
            <div class="loading-text">Initializing NigmaJS...</div>
        </div>
    </div>

    <!-- Navbar injected by navbar.js -->
    <div class="container">
        <header class="guesser-header">
            <h1>üîì Universal Decryption Tool <span style="font-size: 0.5em; vertical-align: middle; background: #f59e0b; color: #000; padding: 2px 8px; border-radius: 4px; margin-left: 10px;">EXPERIMENTAL</span></h1>
            <p class="subtitle">Automated cryptanalysis sandbox. Work in progress.</p>
        </header>

        <!-- Disclaimer / Limitations -->
        <div class="input-card" style="border-left: 4px solid #f59e0b; background: rgba(245, 158, 11, 0.05);">
            <h3 style="color: #f59e0b; margin-top: 0;">‚ö†Ô∏è Early Development Stage</h3>
            <p style="font-size: 0.9rem; margin-bottom: 0;">
                This tool is currently <strong>experimental</strong> and may fail often. Automated decryption is statistical and requires specific conditions to work:
            </p>
            <ul style="font-size: 0.9rem; color: #94a3b8; margin-top: 0.5rem; padding-left: 1.5rem;">
                <li><strong>Text Length:</strong> Requires at least 50-100 characters for accurate statistics.</li>
                <li><strong>Language:</strong> Optimized for standard English. Slang, mixed languages, or numbers will confuse it.</li>
                <li><strong>Supported Ciphers:</strong> Currently targets Caesar, Vigen√®re, and Simple Substitution only.</li>
            </ul>
        </div>

        <div class="input-card">
            <h2>üìù Ciphered Text</h2>
            <textarea id="cipherInput" placeholder="Paste ciphertext here (must be simple substitution)..."></textarea>
            
            <div id="progressContainer" style="margin-top: 1rem; display: none;">
                <div style="display: flex; justify-content: space-between; margin-bottom: 0.5rem;">
                    <span style="color: var(--text-muted);">Decrypting...</span>
                    <span id="progressText" style="color: var(--accent);">0%</span>
                </div>
                <div style="width: 100%; height: 8px; background: rgba(255,255,255,0.1); border-radius: 4px; overflow: hidden;">
                    <div id="progressBar" style="width: 0%; height: 100%; background: var(--accent); transition: width 0.2s;"></div>
                </div>
            </div>

            <button id="btnSolve" class="tab-btn active" style="margin-top: 1rem; width: 100%; text-align: center;">
                üöÄ Attempt Decryption
            </button>
        </div>

            <div id="resultsContainer" class="input-card" style="display: none; border-color: var(--success);">
                <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 1rem;">
                    <h2 style="margin: 0;">üîì Decrypted Result (Live Preview)</h2>
                    <span id="methodBadge" style="background: rgba(255,255,255,0.1); padding: 4px 8px; border-radius: 4px; font-size: 0.8rem; color: var(--accent);">
                        Method: HMM
                    </span>
                </div>
                <p id="decryptedOutput" style="font-family: monospace; white-space: pre-wrap; word-wrap: break-word; overflow-wrap: break-word; color: #e2e8f0; font-size: 1.1rem; line-height: 1.6;"></p>
            </div>

            <div class="input-card">
                <h3>How it works</h3>
                <p style="color: #94a3b8; font-size: 0.9rem; line-height: 1.6;">
                    This tool uses a multi-stage attack:
                    <br><br>
                    <strong>1. Vigen√®re Analysis (Friedman Test):</strong> Checks for polyalphabetic patterns (Index of Coincidence). If detected, it finds the key length and solves each column as a Caesar shift.
                    <br>
                    <strong>2. Brute Force (Caesar Shift):</strong> Instantly checks all 26 simple shifts using Bigram analysis.
                    <br>
                    <strong>3. Hidden Markov Models (HMM):</strong> For complex substitution ciphers, it uses a probabilistic model to "learn" the key mapping from scratch.
                    <br><br>
                    <em>Note: HMM requires enough text (>50 chars) to analyze statistics effectively.</em>
                </p>
            </div>
    </div>

    <script src="js/nigma.min.js"></script>
    <script src="js/navbar.js"></script>
    <script>
        document.addEventListener('DOMContentLoaded', () => {
            // Check Library and Hide Loader
            function checkLibrary() {
                if (window.nigmajs && window.nigmajs.HMMSolver) {
                    const loader = document.getElementById('loading-overlay');
                    if (loader) {
                        loader.classList.add('hidden');
                        setTimeout(() => loader.remove(), 500);
                    }
                } else {
                    setTimeout(checkLibrary, 200);
                }
            }
            checkLibrary();

            const btnSolve = document.getElementById('btnSolve');
            const input = document.getElementById('cipherInput');
            const output = document.getElementById('decryptedOutput');
            const container = document.getElementById('resultsContainer');
            const progressContainer = document.getElementById('progressContainer');
            const progressBar = document.getElementById('progressBar');
            const progressText = document.getElementById('progressText');
            const methodBadge = document.getElementById('methodBadge');

            // Helper: Apply decrypted letters back to original layout (preserving spaces/numbers)
            function matchLayout(original, cleanDecrypted) {
                let result = "";
                let cleanIndex = 0;
                for (let i = 0; i < original.length; i++) {
                    const char = original[i];
                    if (char.match(/[a-zA-Z]/)) {
                        // It's a letter, use the decrypted one
                        if (cleanIndex < cleanDecrypted.length) {
                            const decChar = cleanDecrypted[cleanIndex];
                            // Maintain original case
                            result += (char === char.toUpperCase()) ? decChar.toUpperCase() : decChar.toLowerCase();
                            cleanIndex++;
                        } else {
                            result += char; // Fallback
                        }
                    } else {
                        // Not a letter (space, number), keep as is
                        result += char;
                    }
                }
                return result;
            }

            // Helper: Random Char for Matrix Effect
            const randomChar = () => "ABCDEFGHIJKLMNOPQRSTUVWXYZ"[Math.floor(Math.random() * 26)];

            btnSolve.addEventListener('click', async () => {
                const text = input.value;
                if (!text) return;

                btnSolve.innerText = "‚è≥ Solving...";
                btnSolve.disabled = true;
                output.innerText = "";
                container.style.display = 'block'; 
                progressContainer.style.display = 'block';
                methodBadge.innerText = "Method: Detecting...";
                
                // Reset Badge
                methodBadge.style.color = 'var(--accent)';
                methodBadge.style.borderColor = 'var(--border)';

                // Wait for UI update
                setTimeout(async () => {
                    try {
                        const { HMMSolver, VigenereSolver } = window.nigmajs;
                        if (!HMMSolver || !VigenereSolver) throw new Error("Library not loaded.");

                        // --- 1. Try Vigen√®re Solver First ---
                        const vigenereSolver = new VigenereSolver('english');
                        const vResult = vigenereSolver.solve(text);
                        
                        // If high confidence (IoC match) and key length > 1 (not Caesar)
                        if (vResult.confidence > 0.85 && vResult.analysis.length > 1) {
                            progressBar.style.width = '100%';
                            progressText.innerText = 'Done!';
                            output.innerText = matchLayout(text, vResult.plaintext);
                            
                            methodBadge.innerText = `Method: Vigen√®re (Key: ${vResult.key})`;
                            methodBadge.style.color = '#8b5cf6'; // Purple
                            methodBadge.style.borderColor = '#8b5cf6';
                            
                            container.scrollIntoView({ behavior: 'smooth' });
                            btnSolve.innerText = "üöÄ Attempt Decryption";
                            btnSolve.disabled = false;
                            return; // Stop here
                        }

                        // --- 2. Fallback to HMM (handles Caesar + Substitution) ---
                        const solver = new HMMSolver('english');
                        // Initialize with text to use Frequency Analysis Smart Init
                        await solver.initialize(text);
                        
                        let finalCleanText = "";

                        // Use Generator
                        for await (const status of solver.solveGenerator(text, 150)) { // Increased iterations slightly
                            // Update Progress
                            progressBar.style.width = `${status.progress}%`;
                            progressText.innerText = `Iteration ${status.iteration}/${status.totalIterations}`;
                            
                            // --- MATRIX EFFECT LOGIC ---
                            const isFinished = status.progress >= 100;
                            let displayStr = "";

                            if (status.method === 'caesar' || isFinished) {
                                // Done: Show clean result formatted nicely
                                displayStr = matchLayout(text, status.decryptedText);
                                finalCleanText = status.decryptedText;
                            } else {
                                // In Progress: Scramble Effect
                                // 1. Get current best guess from HMM (stripped)
                                const currentGuess = status.decryptedText === "Optimizing..." ? 
                                    text.replace(/[^a-zA-Z]/g, '') : status.decryptedText;
                                
                                // 2. Add noise to the guess
                                let noisyGuess = "";
                                for(let i=0; i<currentGuess.length; i++) {
                                    // 20% chance to show random char instead of guess (Flicker effect)
                                    if (Math.random() < 0.2) {
                                        noisyGuess += randomChar();
                                    } else {
                                        noisyGuess += currentGuess[i];
                                    }
                                }

                                // 3. Map back to original layout
                                displayStr = matchLayout(text, noisyGuess);
                            }

                            output.innerText = displayStr;
                            
                            // Update Method Badge
                            if (status.method) {
                                methodBadge.innerText = `Method: ${status.method === 'caesar' ? 'Brute Force (Caesar)' : 'HMM (Substitution)'}`;
                                if (status.method === 'caesar') {
                                    methodBadge.style.color = '#10b981'; 
                                    methodBadge.style.borderColor = '#10b981';
                                } else {
                                    methodBadge.style.color = '#f59e0b';
                                    methodBadge.style.borderColor = '#f59e0b';
                                }
                            }
                            
                            if (status.iteration === 1) container.scrollIntoView({ behavior: 'smooth' });
                            
                            // Allow UI render
                            await new Promise(r => setTimeout(r, 10)); 
                        }
                        
                        progressText.innerText = "Done!";
                        progressBar.style.background = "#10b981";

                    } catch (e) {
                        console.error(e);
                        alert("Error: " + e.message);
                    } finally {
                        btnSolve.innerText = "üöÄ Attempt Decryption";
                        btnSolve.disabled = false;
                    }
                }, 100);
            });
        });
    </script>
</body>
</html>

