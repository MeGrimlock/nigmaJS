<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>NigmaJS - HMM Decryption Tool</title>
    <link rel="stylesheet" href="css/styles.css">
    <link rel="stylesheet" href="css/guesser.css">
    <link rel="stylesheet" href="css/navbar.css">
    <!-- TensorFlow.js is already included in nigma.min.js, no need to load separately -->
    <!-- This prevents duplicate kernel registration warnings -->
</head>
<body>
    <!-- Loading Overlay -->
    <div id="loading-overlay">
        <div class="loader-container">
            <div class="spinner"></div>
            <div class="loading-text">Initializing NigmaJS...</div>
        </div>
    </div>

    <!-- Navbar injected by navbar.js -->
    <div class="container">
        <header class="guesser-header">
            <h1>üîì Universal Decryption Tool <span style="font-size: 0.5em; vertical-align: middle; background: #f59e0b; color: #000; padding: 2px 8px; border-radius: 4px; margin-left: 10px;">EXPERIMENTAL</span></h1>
            <p class="subtitle">Automated cryptanalysis sandbox. Work in progress.</p>
        </header>

        <!-- Disclaimer / Limitations -->
        <div class="input-card" style="border-left: 4px solid #f59e0b; background: rgba(245, 158, 11, 0.05);">
            <h3 style="color: #f59e0b; margin-top: 0;">‚ö†Ô∏è Early Development Stage</h3>
            <p style="font-size: 0.9rem; margin-bottom: 0;">
                This tool is currently <strong>experimental</strong> and may fail often. Automated decryption is statistical and requires specific conditions to work:
            </p>
            <ul style="font-size: 0.9rem; color: #94a3b8; margin-top: 0.5rem; padding-left: 1.5rem;">
                <li><strong>Text Length:</strong> Requires at least 50-100 characters for accurate statistics.</li>
                <li><strong>Language:</strong> Optimized for standard English. Slang, mixed languages, or numbers will confuse it.</li>
                <li><strong>Supported Ciphers:</strong> Currently targets Caesar, Vigen√®re, and Simple Substitution only.</li>
            </ul>
        </div>

        <!-- Two Column Layout -->
        <div style="display: grid; grid-template-columns: 70% 30%; gap: 1.5rem; margin-bottom: 1.5rem;">
            <!-- Left Column: Input -->
            <div class="input-card">
                <h2>üìù Ciphered Text</h2>
                <textarea id="cipherInput" placeholder="Paste ciphertext here to analyze and decrypt..." style="min-height: 400px;"></textarea>
                
                <div id="progressContainer" style="margin-top: 1rem; display: none;">
                    <div style="display: flex; justify-content: space-between; margin-bottom: 0.5rem;">
                        <span style="color: var(--text-muted);">Decrypting...</span>
                        <span id="progressText" style="color: var(--accent);">0%</span>
                    </div>
                    <div style="width: 100%; height: 8px; background: rgba(255,255,255,0.1); border-radius: 4px; overflow: hidden;">
                        <div id="progressBar" style="width: 0%; height: 100%; background: var(--accent); transition: width 0.2s;"></div>
                    </div>
                </div>
                
                <!-- Analysis Console -->
                <div id="analysisConsole" style="margin-top: 1rem; display: none; max-height: 300px; overflow-y: auto; background: rgba(0,0,0,0.3); border-radius: 8px; padding: 1rem; font-family: 'Courier New', monospace; font-size: 0.8rem;">
                    <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 0.75rem;">
                        <h3 style="margin: 0; color: #a78bfa; font-size: 0.9rem; text-transform: uppercase; letter-spacing: 0.5px;">üìä Analysis Console</h3>
                        <button id="clearConsoleBtn" style="background: rgba(255,255,255,0.1); border: 1px solid rgba(255,255,255,0.2); color: #94a3b8; padding: 4px 8px; border-radius: 4px; cursor: pointer; font-size: 0.7rem;">Clear</button>
                    </div>
                    <div id="consoleContent" style="display: flex; flex-direction: column; gap: 0.4rem;">
                        <!-- Console messages will be added here -->
                    </div>
                </div>

                <button id="btnSolve" class="tab-btn" style="margin-top: 1rem; width: 100%; text-align: center; opacity: 0.5; cursor: not-allowed;" disabled>
                    üìù Enter text to begin
                </button>
            </div>

            <!-- Right Column: Live Analysis -->
            <div style="display: flex; flex-direction: column; gap: 1rem;">
                <!-- Text Statistics -->
                <div class="input-card" style="padding: 1rem;">
                    <h3 style="margin: 0 0 0.75rem 0; font-size: 0.9rem; color: #94a3b8; text-transform: uppercase; letter-spacing: 0.5px;">üìä Text Statistics</h3>
                    <div id="textStatsContent" style="font-size: 0.85rem; color: #e2e8f0;">
                        <div style="color: #64748b; font-style: italic;">No text to analyze</div>
                    </div>
                </div>

                <!-- Cipher Detection -->
                <div class="input-card" style="padding: 1rem;">
                    <h3 style="margin: 0 0 0.75rem 0; font-size: 0.9rem; color: #a78bfa; text-transform: uppercase; letter-spacing: 0.5px;">üîç Cipher Detection</h3>
                    <div id="cipherDetectionContent" style="font-size: 0.85rem; color: #e2e8f0;">
                        <div style="color: #64748b; font-style: italic;">Waiting for input...</div>
                    </div>
                </div>

                <!-- Language Probability -->
                <div class="input-card" style="padding: 1rem;">
                    <h3 style="margin: 0 0 0.75rem 0; font-size: 0.9rem; color: #10b981; text-transform: uppercase; letter-spacing: 0.5px;">üåê Language Probability</h3>
                    <div id="languageProbContent" style="font-size: 0.85rem; color: #e2e8f0;">
                        <div style="color: #64748b; font-style: italic;">Analyzing...</div>
                    </div>
                </div>
            </div>
        </div>

            <div id="resultsContainer" class="input-card" style="display: none; border-color: var(--success);">
                <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 1rem;">
                    <h2 style="margin: 0;">üîì Decrypted Result (Live Preview)</h2>
                    <span id="methodBadge" style="background: rgba(255,255,255,0.1); padding: 4px 8px; border-radius: 4px; font-size: 0.8rem; color: var(--accent);">
                        Method: HMM
                    </span>
                </div>
                <p id="decryptedOutput" style="font-family: monospace; white-space: pre-wrap; word-wrap: break-word; overflow-wrap: break-word; color: #e2e8f0; font-size: 1.1rem; line-height: 1.6;"></p>
                
                <!-- Dictionary Validation Section -->
                <div id="dictionaryValidationContainer" style="display: none; margin-top: 1.5rem; padding: 1rem; background: rgba(16, 185, 129, 0.1); border-left: 4px solid #10b981; border-radius: 8px;">
                    <h3 style="margin-top: 0; color: #10b981; font-size: 1rem; display: flex; align-items: center; gap: 0.5rem;">
                        üìö Dictionary Validation
                        <span id="dictValidBadge" style="font-size: 0.75rem; padding: 2px 6px; border-radius: 4px; background: rgba(16, 185, 129, 0.2);">VALID</span>
                    </h3>
                    <div id="dictionaryValidationContent" style="font-size: 0.9rem; color: #e2e8f0;">
                        <!-- Dynamic content will be inserted here -->
                    </div>
                </div>
            </div>

            <div class="input-card">
                <h3>How it works</h3>
                <p style="color: #94a3b8; font-size: 0.9rem; line-height: 1.6;">
                    This tool uses an <strong>Intelligent Orchestrator</strong> that automatically detects and attacks classical ciphers:
                    <br><br>
                    <strong>üîç Step 1 - Detection:</strong> Analyzes Index of Coincidence (IC), Entropy, and Kasiski patterns to identify cipher type.
                    <br>
                    <strong>üéØ Step 2 - Strategy Selection:</strong> Chooses the optimal attack based on detection:
                    <ul style="margin: 0.5rem 0 0.5rem 1.5rem; padding: 0;">
                        <li><strong>Caesar/ROT13:</strong> Brute force (26 rotations) with N-gram scoring</li>
                        <li><strong>Vigen√®re:</strong> Friedman Test + frequency analysis per column</li>
                        <li><strong>Substitution:</strong> Hill Climbing or Simulated Annealing with quadgram scoring</li>
                        <li><strong>Advanced Polyalphabetic:</strong> Beaufort, Porta, Gronsfeld, Quagmire (experimental)</li>
                    </ul>
                    <strong>‚ö° Step 3 - Execution:</strong> Runs the selected attack and returns the best result.
                    <br>
                    <strong>üìö Step 4 - Dictionary Validation:</strong> Validates the decrypted text against a 275k+ word English dictionary to measure confidence:
                    <ul style="margin: 0.5rem 0 0.5rem 1.5rem; padding: 0;">
                        <li><strong>Word Coverage:</strong> % of valid dictionary words found</li>
                        <li><strong>Character Coverage:</strong> % of characters in valid words</li>
                        <li><strong>Confidence Score:</strong> Weighted metric (0-100%) combining all factors</li>
                    </ul>
                    <br>
                    <strong>üìä Powered by:</strong> N-gram models (quadgrams), log-likelihood scoring, heuristic search algorithms, and dictionary validation.
                    <br><br>
                    <strong>‚ö†Ô∏è Current Limitations:</strong>
                    <ul style="margin: 0.5rem 0 0 1.5rem; padding: 0; font-size: 0.85rem; color: #f59e0b;">
                        <li><strong>Beaufort:</strong> ~40-60% success rate (requires >200 chars)</li>
                        <li><strong>Porta:</strong> ~60-70% success rate</li>
                        <li><strong>Quagmire:</strong> ~20-30% success rate (very difficult without known alphabet)</li>
                        <li><strong>General:</strong> Longer texts and shorter keys improve accuracy significantly</li>
                    </ul>
                    <br>
                    <em>Note: This is an experimental tool. For production cryptanalysis, combine with manual analysis.</em>
                </p>
            </div>
    </div>

    <script src="js/nigma.min.js"></script>
    <script src="js/navbar.js"></script>
    <script>
        document.addEventListener('DOMContentLoaded', () => {
            // Suppress TensorFlow.js kernel registration warnings
            // These warnings occur when kernels are registered multiple times
            // They're harmless but clutter the console
            const originalWarn = console.warn;
            console.warn = function(...args) {
                const message = args[0];
                // Filter out TensorFlow kernel registration warnings
                if (typeof message === 'string' && (
                    message.includes('kernel') && message.includes('already registered') ||
                    message.includes('backend was already registered')
                )) {
                    return; // Suppress this warning
                }
                // Allow all other warnings through
                originalWarn.apply(console, args);
            };
            
            // Check Library and Hide Loader
            function checkLibrary() {
                if (window.nigmajs && (window.nigmajs.Orchestrator || window.nigmajs.HMMSolver)) {
                    const loader = document.getElementById('loading-overlay');
                    if (loader) {
                        loader.classList.add('hidden');
                        setTimeout(() => loader.remove(), 500);
                    }
                } else {
                    setTimeout(checkLibrary, 200);
                }
            }
            checkLibrary();

            const btnSolve = document.getElementById('btnSolve');
            const input = document.getElementById('cipherInput');
            const output = document.getElementById('decryptedOutput');
            const container = document.getElementById('resultsContainer');
            const progressContainer = document.getElementById('progressContainer');
            const progressBar = document.getElementById('progressBar');
            const progressText = document.getElementById('progressText');
            const methodBadge = document.getElementById('methodBadge');
            const cipherDetectionContent = document.getElementById('cipherDetectionContent');
            const textStatsContent = document.getElementById('textStatsContent');
            const languageProbContent = document.getElementById('languageProbContent');
            
            let hasAttemptedDecryption = false;
            let lastDecryptionSuccess = false;

            // Helper: Apply decrypted letters back to original layout (preserving spaces/numbers)
            function matchLayout(original, cleanDecrypted) {
                let result = "";
                let cleanIndex = 0;
                for (let i = 0; i < original.length; i++) {
                    const char = original[i];
                    if (char.match(/[a-zA-Z]/)) {
                        // It's a letter, use the decrypted one
                        if (cleanIndex < cleanDecrypted.length) {
                            const decChar = cleanDecrypted[cleanIndex];
                            // Maintain original case
                            result += (char === char.toUpperCase()) ? decChar.toUpperCase() : decChar.toLowerCase();
                            cleanIndex++;
                        } else {
                            result += char; // Fallback
                        }
                    } else {
                        // Not a letter (space, number), keep as is
                        result += char;
                    }
                }
                return result;
            }

            // Helper: Random Char for Matrix Effect
            const randomChar = () => "ABCDEFGHIJKLMNOPQRSTUVWXYZ"[Math.floor(Math.random() * 26)];

            // Update button state based on input
            function updateButtonState() {
                const text = input.value.trim();
                
                if (text.length === 0) {
                    // No text - disabled state
                    btnSolve.disabled = true;
                    btnSolve.style.opacity = '0.5';
                    btnSolve.style.cursor = 'not-allowed';
                    btnSolve.classList.remove('active');
                    btnSolve.innerHTML = 'üìù Enter text to begin';
                } else if (!hasAttemptedDecryption) {
                    // Has text, not attempted yet
                    btnSolve.disabled = false;
                    btnSolve.style.opacity = '1';
                    btnSolve.style.cursor = 'pointer';
                    btnSolve.classList.add('active');
                    btnSolve.innerHTML = 'üöÄ Attempt Decryption';
                } else {
                    // Has attempted - show retry
                    btnSolve.disabled = false;
                    btnSolve.style.opacity = '1';
                    btnSolve.style.cursor = 'pointer';
                    btnSolve.classList.add('active');
                    btnSolve.innerHTML = lastDecryptionSuccess ? 'üîÑ Retry Decryption' : 'üîÑ Retry';
                }
            }

            // Live Analysis on Input Change (with debounce)
            let analysisTimeout;
            input.addEventListener('input', () => {
                updateButtonState();
                
                clearTimeout(analysisTimeout);
                analysisTimeout = setTimeout(() => {
                    const text = input.value.trim();
                    
                    // Update Text Statistics
                    if (text.length === 0) {
                        textStatsContent.innerHTML = '<div style="color: #64748b; font-style: italic;">No text to analyze</div>';
                        cipherDetectionContent.innerHTML = '<div style="color: #64748b; font-style: italic;">Waiting for input...</div>';
                        languageProbContent.innerHTML = '<div style="color: #64748b; font-style: italic;">Analyzing...</div>';
                        return;
                    }
                    
                    const { Stats, LanguageAnalysis, CipherIdentifier } = window.nigmajs;
                    if (!Stats || !LanguageAnalysis || !CipherIdentifier) return;
                    
                    // Text Statistics
                    const cleanText = text.toUpperCase().replace(/[^A-Z]/g, '');
                    const ic = Stats.indexOfCoincidence(text).toFixed(2);
                    const entropy = Stats.entropy(text).toFixed(2);
                    
                    let statsHtml = '<div style="display: flex; flex-direction: column; gap: 0.5rem;">';
                    statsHtml += `<div style="display: flex; justify-content: space-between;">
                        <span style="color: #94a3b8;">Length:</span>
                        <span style="color: #e2e8f0; font-weight: bold;">${text.length} chars</span>
                    </div>`;
                    statsHtml += `<div style="display: flex; justify-content: space-between;">
                        <span style="color: #94a3b8;">Letters:</span>
                        <span style="color: #e2e8f0; font-weight: bold;">${cleanText.length}</span>
                    </div>`;
                    statsHtml += `<div style="display: flex; justify-content: space-between;">
                        <span style="color: #94a3b8;">IC:</span>
                        <span style="color: ${ic > 1.5 ? '#10b981' : ic > 1.2 ? '#f59e0b' : '#ef4444'}; font-weight: bold;">${ic}</span>
                    </div>`;
                    statsHtml += `<div style="display: flex; justify-content: space-between;">
                        <span style="color: #94a3b8;">Entropy:</span>
                        <span style="color: ${entropy > 4 ? '#ef4444' : entropy > 3 ? '#f59e0b' : '#10b981'}; font-weight: bold;">${entropy}</span>
                    </div>`;
                    statsHtml += '</div>';
                    textStatsContent.innerHTML = statsHtml;
                    
                    if (text.length < 20) {
                        cipherDetectionContent.innerHTML = '<div style="color: #f59e0b; font-size: 0.8rem;">Need at least 20 characters for analysis</div>';
                        languageProbContent.innerHTML = '<div style="color: #64748b; font-style: italic;">Not enough text</div>';
                        return;
                    }

                    // Show loading state
                    cipherDetectionContent.innerHTML = '<div style="color: #64748b; font-style: italic; font-size: 0.75rem;">üîç Analyzing cipher...</div>';
                    languageProbContent.innerHTML = '<div style="color: #64748b; font-style: italic; font-size: 0.75rem;">üåê Detecting language...</div>';
                    
                    // Run async analyses in parallel
                    Promise.all([
                        // Cipher Detection
                        (async () => {
                            try {
                                const { CipherIdentifier } = window.nigmajs;
                                const result = await CipherIdentifier.identify(text, 'auto');
                                
                                // Build HTML for cipher detection (compact for sidebar)
                                let cipherHtml = '<div style="display: flex; flex-direction: column; gap: 0.5rem;">';
                                
                                if (result.families && result.families.length > 0) {
                                    result.families.slice(0, 5).forEach((family, index) => {
                                        const icon = index === 0 ? 'ü•á' : index === 1 ? 'ü•à' : index === 2 ? 'ü•â' : index === 3 ? '4Ô∏è‚É£' : '5Ô∏è‚É£';
                                        const confidencePercent = (family.confidence * 100).toFixed(0);
                                        const confidenceColor = family.confidence > 0.7 ? '#10b981' : family.confidence > 0.4 ? '#f59e0b' : '#94a3b8';
                                        
                                        // Format cipher type name
                                        const typeName = family.type
                                            .replace(/-/g, ' ')
                                            .split(' ')
                                            .map(word => word.charAt(0).toUpperCase() + word.slice(1))
                                            .join(' ');
                                        
                                        cipherHtml += `<div style="display: flex; justify-content: space-between; align-items: center; padding: 0.5rem; background: rgba(255,255,255,0.05); border-radius: 4px;">
                                            <div style="flex: 1;">
                                                <span style="margin-right: 0.4rem;">${icon}</span>
                                                <strong style="color: #e2e8f0; font-size: 0.75rem;">${typeName}</strong>
                                            </div>
                                            <div style="display: flex; align-items: center; gap: 0.4rem;">
                                                <div style="width: 35px; height: 4px; background: rgba(255,255,255,0.1); border-radius: 2px; overflow: hidden;">
                                                    <div style="width: ${confidencePercent}%; height: 100%; background: ${confidenceColor};"></div>
                                                </div>
                                                <span style="color: ${confidenceColor}; font-size: 0.7rem; font-weight: bold; min-width: 30px;">${confidencePercent}%</span>
                                            </div>
                                        </div>`;
                                    });
                                } else {
                                    cipherHtml += '<div style="color: #f59e0b; font-size: 0.75rem;">Unable to detect cipher type</div>';
                                }
                                
                                cipherHtml += '</div>';
                                cipherDetectionContent.innerHTML = cipherHtml;
                            } catch (error) {
                                console.error('Cipher detection error:', error);
                                cipherDetectionContent.innerHTML = '<div style="color: #ef4444; font-size: 0.75rem;">Cipher detection error</div>';
                            }
                        })(),
                        
                        // Language Probability
                        (async () => {
                            try {
                                const { LanguageAnalysis } = window.nigmajs;
                                const langResults = await LanguageAnalysis.detectLanguage(text);
                                
                                let langHtml = '<div style="display: flex; flex-direction: column; gap: 0.4rem;">';
                                
                                if (!langResults || langResults.length === 0) {
                                    langHtml += '<div style="color: #64748b; font-style: italic; font-size: 0.75rem;">No language data available</div>';
                                } else {
                                    // Calculate probabilities from identityScore (lower is better for identityScore)
                                    const validResults = langResults.filter(lang => 
                                        lang && 
                                        typeof lang.identityScore === 'number' && 
                                        !isNaN(lang.identityScore) && 
                                        isFinite(lang.identityScore)
                                    );
                                    
                                    if (validResults.length === 0) {
                                        langHtml += '<div style="color: #f59e0b; font-style: italic; font-size: 0.75rem;">Unable to analyze language</div>';
                                    } else {
                                        // Convert identityScore to probability (lower score = higher probability)
                                        const maxScore = Math.max(...validResults.map(l => l.identityScore));
                                        const minScore = Math.min(...validResults.map(l => l.identityScore));
                                        const scoreRange = maxScore - minScore;
                                        
                                        validResults.slice(0, 5).forEach((lang, index) => {
                                            const langName = lang.language ? lang.language.charAt(0).toUpperCase() + lang.language.slice(1) : 'Unknown';
                                            
                                            // Calculate probability: lower identityScore = higher probability
                                            let probability = '0';
                                            if (scoreRange > 0.001) {
                                                // Invert: (maxScore - identityScore) / range * 100
                                                const normalizedScore = ((maxScore - lang.identityScore) / scoreRange) * 100;
                                                probability = Math.max(0, Math.min(100, normalizedScore)).toFixed(0);
                                            } else {
                                                // All scores are very similar, distribute evenly
                                                probability = Math.round(100 / validResults.length).toString();
                                            }
                                            
                                            // Ensure probability is a valid number
                                            if (isNaN(probability) || !isFinite(parseFloat(probability))) {
                                                probability = '0';
                                            }
                                            
                                            const color = index === 0 ? '#10b981' : index === 1 ? '#3b82f6' : '#64748b';
                                        
                                            langHtml += `<div style="display: flex; justify-content: space-between; align-items: center; padding: 0.4rem; background: rgba(255,255,255,0.03); border-radius: 4px;">
                                                <span style="color: ${color}; font-size: 0.75rem; font-weight: ${index === 0 ? 'bold' : 'normal'};">${langName}</span>
                                                <div style="display: flex; align-items: center; gap: 0.4rem;">
                                                    <div style="width: 40px; height: 4px; background: rgba(255,255,255,0.1); border-radius: 2px; overflow: hidden;">
                                                        <div style="width: ${probability}%; height: 100%; background: ${color};"></div>
                                                    </div>
                                                    <span style="color: ${color}; font-size: 0.7rem; min-width: 30px;">${probability}%</span>
                                                </div>
                                            </div>`;
                                        });
                                    }
                                }
                                
                                langHtml += '</div>';
                                languageProbContent.innerHTML = langHtml;
                            } catch (langError) {
                                console.error('Language probability error:', langError);
                                languageProbContent.innerHTML = '<div style="color: #ef4444; font-size: 0.75rem;">Language analysis error</div>';
                            }
                        })()
                    ]).catch(error => {
                        console.error('Analysis error:', error);
                        cipherDetectionContent.innerHTML = '<div style="color: #ef4444; font-size: 0.75rem;">Analysis error</div>';
                    });
                }, 500); // 500ms debounce
            });
            
            // Initial button state
            updateButtonState();

            // Console management
            const analysisConsole = document.getElementById('analysisConsole');
            const consoleContent = document.getElementById('consoleContent');
            const clearConsoleBtn = document.getElementById('clearConsoleBtn');
            
            function addConsoleMessage(message, type = 'info') {
                const timestamp = new Date().toLocaleTimeString();
                const colors = {
                    info: '#3b82f6',
                    success: '#10b981',
                    warning: '#f59e0b',
                    error: '#ef4444',
                    progress: '#a78bfa'
                };
                const icons = {
                    info: '‚ÑπÔ∏è',
                    success: '‚úì',
                    warning: '‚ö†Ô∏è',
                    error: '‚úó',
                    progress: '‚è≥'
                };
                
                const messageDiv = document.createElement('div');
                messageDiv.style.cssText = `display: flex; align-items: flex-start; gap: 0.5rem; padding: 0.4rem; background: rgba(255,255,255,0.02); border-left: 2px solid ${colors[type]}; border-radius: 4px;`;
                messageDiv.innerHTML = `
                    <span style="color: ${colors[type]}; font-size: 0.7rem; min-width: 50px;">${timestamp}</span>
                    <span style="color: ${colors[type]}; margin-right: 0.3rem;">${icons[type]}</span>
                    <span style="color: #e2e8f0; flex: 1;">${message}</span>
                `;
                
                consoleContent.appendChild(messageDiv);
                // Auto-scroll to bottom
                analysisConsole.scrollTop = analysisConsole.scrollHeight;
            }
            
            clearConsoleBtn.addEventListener('click', () => {
                consoleContent.innerHTML = '';
            });
            
            btnSolve.addEventListener('click', async () => {
                const text = input.value;
                if (!text) return;

                hasAttemptedDecryption = true;
                btnSolve.innerText = "‚è≥ Solving...";
                btnSolve.disabled = true;
                output.innerText = "";
                container.style.display = 'block'; 
                progressContainer.style.display = 'block';
                analysisConsole.style.display = 'block';
                consoleContent.innerHTML = ''; // Clear console
                methodBadge.innerText = "Method: Detecting...";
                progressText.innerText = "Decrypting...";
                
                // Reset Badge
                methodBadge.style.color = 'var(--accent)';
                methodBadge.style.borderColor = 'var(--border)';

                // Wait for UI update
                setTimeout(async () => {
                    try {
                        const { Orchestrator } = window.nigmajs;
                        if (!Orchestrator) throw new Error("Orchestrator not loaded.");

                        // --- Use Orchestrator with Auto Language Detection & Dictionary Validation ---
                        // 'auto' enables automatic language detection before decryption
                        const orchestrator = new Orchestrator('auto');
                        
                        let finalResult = null;
                        
                        // Use generator for real-time progress
                        for await (const update of orchestrator.autoDecryptGenerator(text, {
                            tryMultiple: true,
                            useDictionary: true,
                            maxTime: 60000
                        })) {
                            // Update progress bar
                            if (update.progress !== undefined) {
                                progressBar.style.width = `${update.progress}%`;
                                progressText.innerText = `${Math.round(update.progress)}%`;
                            }
                            
                            // Add console message based on stage
                            if (update.stage === 'language-detection') {
                                addConsoleMessage(update.message, 'progress');
                            } else if (update.stage === 'language-detected') {
                                addConsoleMessage(update.message, 'success');
                            } else if (update.stage === 'cipher-detection') {
                                addConsoleMessage(update.message, 'progress');
                            } else if (update.stage === 'cipher-detected') {
                                addConsoleMessage(update.message, 'success');
                            } else if (update.stage === 'strategies-selected') {
                                addConsoleMessage(update.message, 'info');
                            } else if (update.stage === 'trying-strategy') {
                                addConsoleMessage(update.message, 'progress');
                            } else if (update.stage === 'solving') {
                                // Don't spam console with every iteration, only show significant progress
                                if (update.progress % 10 < 2) { // Show every ~10%
                                    addConsoleMessage(update.message, 'progress');
                                }
                            } else if (update.stage === 'strategy-complete') {
                                addConsoleMessage(update.message, 'success');
                            } else if (update.stage === 'strategy-failed') {
                                addConsoleMessage(update.message, 'warning');
                            } else if (update.stage === 'early-stop') {
                                addConsoleMessage(update.message, 'success');
                            } else if (update.stage === 'validating') {
                                addConsoleMessage(update.message, 'progress');
                            } else if (update.stage === 'validation-complete') {
                                addConsoleMessage(update.message, 'success');
                            } else if (update.stage === 'validation-failed') {
                                addConsoleMessage(update.message, 'warning');
                            } else if (update.stage === 'complete') {
                                addConsoleMessage(update.message, 'success');
                                finalResult = update;
                                console.log('[Demo] Final result received (complete):', {
                                    method: update.method,
                                    confidence: update.confidence,
                                    plaintextLength: update.plaintext?.length || 0,
                                    hasPlaintext: !!update.plaintext
                                });
                            } else if (update.stage === 'failed') {
                                addConsoleMessage(update.message, 'error');
                                finalResult = update;
                                console.log('[Demo] Final result received (failed):', {
                                    method: update.method,
                                    confidence: update.confidence,
                                    plaintextLength: update.plaintext?.length || 0
                                });
                            } else if (update.stage === 'timeout') {
                                addConsoleMessage(update.message, 'warning');
                            }
                            
                            // Update preview if we have plaintext (from any stage)
                            if (update.plaintext) {
                                if (update.stage === 'solving' || update.stage === 'strategy-complete' || update.stage === 'complete') {
                                    output.innerText = update.plaintext;
                                }
                                // Update finalResult if:
                                // 1. It's the final complete stage (always use this)
                                // 2. Or it has plaintext and method and we don't have a finalResult yet
                                // 3. Or it has better confidence than current finalResult
                                if (update.plaintext && update.method && update.method !== 'none') {
                                    if (update.stage === 'complete' || update.stage === 'failed') {
                                        // Always use final stage result
                                        console.log('[Demo] Setting finalResult from final stage:', {
                                            stage: update.stage,
                                            method: update.method,
                                            confidence: update.confidence,
                                            plaintextLength: update.plaintext.length
                                        });
                                        finalResult = update;
                                    } else if (!finalResult) {
                                        // First result, use it temporarily
                                        console.log('[Demo] Setting temporary finalResult from update:', {
                                            method: update.method,
                                            confidence: update.confidence,
                                            plaintextLength: update.plaintext.length
                                        });
                                        finalResult = update;
                                    } else if (update.confidence && finalResult.confidence && update.confidence > finalResult.confidence) {
                                        // Better confidence, update (but only if not from final stage)
                                        console.log('[Demo] Updating finalResult with better confidence:', {
                                            method: update.method,
                                            confidence: update.confidence,
                                            previousConfidence: finalResult.confidence
                                        });
                                        finalResult = update;
                                    }
                                }
                            }
                        }
                        
                        // Use final result
                        const result = finalResult || {
                            plaintext: text,
                            method: 'none',
                            confidence: 0
                        };
                        
                        console.log('[Demo] Decryption result:', {
                            method: result.method,
                            confidence: result.confidence,
                            plaintextLength: result.plaintext?.length || 0,
                            plaintextPreview: result.plaintext?.substring(0, 100) || 'N/A',
                            hasPlaintext: !!result.plaintext,
                            finalResultWasNull: !finalResult
                        });
                        
                        // Check if decryption was successful
                        const isSuccess = result.plaintext && result.plaintext.length > 0 && result.method !== 'none';
                        
                        // Update progress based on success
                        progressBar.style.width = '100%';
                        if (isSuccess) {
                            progressText.innerText = '‚úì Decryption successful!';
                            progressBar.style.background = "#10b981";
                        } else {
                            progressText.innerText = '‚úó Decryption failed';
                            progressBar.style.background = "#ef4444";
                        }
                        
                        output.innerText = result.plaintext || "‚ùå Decryption failed.";
                        
                        // Update badge with method and confidence
                        const confidencePercent = (result.confidence * 100).toFixed(0);
                        methodBadge.innerText = `Method: ${result.method.toUpperCase()} (${confidencePercent}% confidence)`;
                        
                        // Color based on confidence
                        if (result.confidence > 0.7) {
                            methodBadge.style.color = '#10b981'; // Green
                            methodBadge.style.borderColor = '#10b981';
                        } else if (result.confidence > 0.4) {
                            methodBadge.style.color = '#f59e0b'; // Orange
                            methodBadge.style.borderColor = '#f59e0b';
                        } else {
                            methodBadge.style.color = '#ef4444'; // Red
                            methodBadge.style.borderColor = '#ef4444';
                        }
                        
                        // Display Dictionary Validation if available
                        const dictValidationContainer = document.getElementById('dictionaryValidationContainer');
                        const dictValidationContent = document.getElementById('dictionaryValidationContent');
                        const dictValidBadge = document.getElementById('dictValidBadge');
                        
                        console.log('[Demo] Dictionary validation:', result.dictionaryValidation);
                        
                        if (result.dictionaryValidation && result.dictionaryValidation.metrics) {
                            const validation = result.dictionaryValidation;
                            const metrics = validation.metrics;
                            
                            // Update badge
                            if (validation.valid) {
                                dictValidBadge.innerText = '‚úì VALID';
                                dictValidBadge.style.background = 'rgba(16, 185, 129, 0.3)';
                                dictValidBadge.style.color = '#10b981';
                            } else {
                                dictValidBadge.innerText = '‚ö† UNCERTAIN';
                                dictValidBadge.style.background = 'rgba(245, 158, 11, 0.3)';
                                dictValidBadge.style.color = '#f59e0b';
                            }
                            
                            // Build metrics HTML
                            let html = `<p style="color: #94a3b8; margin-bottom: 1rem;">${validation.summary}</p>`;
                            
                            html += '<div style="display: grid; grid-template-columns: repeat(auto-fit, minmax(200px, 1fr)); gap: 1rem;">';
                            
                            // Valid Words
                            html += `<div style="padding: 0.75rem; background: rgba(255,255,255,0.05); border-radius: 6px;">
                                <div style="font-size: 0.75rem; color: #94a3b8; text-transform: uppercase; letter-spacing: 0.5px;">Valid Words</div>
                                <div style="font-size: 1.5rem; font-weight: bold; color: #10b981; margin-top: 0.25rem;">${metrics.validWords} / ${metrics.totalWords}</div>
                                <div style="font-size: 0.8rem; color: #64748b; margin-top: 0.25rem;">${metrics.wordCoverage}% coverage</div>
                            </div>`;
                            
                            // Character Coverage
                            html += `<div style="padding: 0.75rem; background: rgba(255,255,255,0.05); border-radius: 6px;">
                                <div style="font-size: 0.75rem; color: #94a3b8; text-transform: uppercase; letter-spacing: 0.5px;">Character Coverage</div>
                                <div style="font-size: 1.5rem; font-weight: bold; color: #3b82f6; margin-top: 0.25rem;">${metrics.charCoverage}%</div>
                                <div style="font-size: 0.8rem; color: #64748b; margin-top: 0.25rem;">${metrics.validChars} / ${metrics.totalChars} chars</div>
                            </div>`;
                            
                            // Average Word Length
                            html += `<div style="padding: 0.75rem; background: rgba(255,255,255,0.05); border-radius: 6px;">
                                <div style="font-size: 0.75rem; color: #94a3b8; text-transform: uppercase; letter-spacing: 0.5px;">Avg Word Length</div>
                                <div style="font-size: 1.5rem; font-weight: bold; color: #8b5cf6; margin-top: 0.25rem;">${metrics.avgWordLength}</div>
                                <div style="font-size: 0.8rem; color: #64748b; margin-top: 0.25rem;">letters per word</div>
                            </div>`;
                            
                            // Confidence Score
                            const dictConfidencePercent = (validation.confidence * 100).toFixed(0);
                            const dictConfidenceColor = validation.confidence > 0.7 ? '#10b981' : validation.confidence > 0.4 ? '#f59e0b' : '#ef4444';
                            html += `<div style="padding: 0.75rem; background: rgba(255,255,255,0.05); border-radius: 6px;">
                                <div style="font-size: 0.75rem; color: #94a3b8; text-transform: uppercase; letter-spacing: 0.5px;">Dictionary Score</div>
                                <div style="font-size: 1.5rem; font-weight: bold; color: ${dictConfidenceColor}; margin-top: 0.25rem;">${dictConfidencePercent}%</div>
                                <div style="font-size: 0.8rem; color: #64748b; margin-top: 0.25rem;">confidence</div>
                            </div>`;
                            
                            html += '</div>';
                            
                            // Sample words found
                            if (validation.foundWords && validation.foundWords.length > 0) {
                                html += `<div style="margin-top: 1rem; padding: 0.75rem; background: rgba(255,255,255,0.03); border-radius: 6px;">
                                    <div style="font-size: 0.75rem; color: #94a3b8; text-transform: uppercase; letter-spacing: 0.5px; margin-bottom: 0.5rem;">Sample Valid Words</div>
                                    <div style="display: flex; flex-wrap: wrap; gap: 0.5rem;">
                                        ${validation.foundWords.map(word => `<span style="padding: 4px 8px; background: rgba(16, 185, 129, 0.2); color: #10b981; border-radius: 4px; font-size: 0.85rem; font-family: monospace;">${word}</span>`).join('')}
                                    </div>
                                </div>`;
                            }
                            
                            dictValidationContent.innerHTML = html;
                            dictValidationContainer.style.display = 'block';
                        } else {
                            // Dictionary validation not available - show fallback message
                            console.warn('[Demo] Dictionary validation not available in result');
                            
                            // Try to manually validate if we have the DictionaryValidator
                            if (window.nigmajs.DictionaryValidator && isSuccess) {
                                try {
                                    // Use detected language from orchestrator, fallback to 'english'
                                    const detectedLanguage = orchestrator.language || 'english';
                                    const validator = new window.nigmajs.DictionaryValidator(detectedLanguage);
                                    const manualValidation = await validator.validate(result.plaintext);
                                    
                                    console.log('[Demo] Manual validation:', manualValidation);
                                    
                                    if (manualValidation && manualValidation.metrics) {
                                        const validation = manualValidation;
                                        const metrics = validation.metrics;
                                        
                                        // Update badge
                                        if (validation.valid) {
                                            dictValidBadge.innerText = '‚úì VALID';
                                            dictValidBadge.style.background = 'rgba(16, 185, 129, 0.3)';
                                            dictValidBadge.style.color = '#10b981';
                                        } else {
                                            dictValidBadge.innerText = '‚ö† UNCERTAIN';
                                            dictValidBadge.style.background = 'rgba(245, 158, 11, 0.3)';
                                            dictValidBadge.style.color = '#f59e0b';
                                        }
                                        
                                        // Build metrics HTML (same as above)
                                        let html = `<p style="color: #94a3b8; margin-bottom: 1rem;">${validation.summary}</p>`;
                                        
                                        html += '<div style="display: grid; grid-template-columns: repeat(auto-fit, minmax(200px, 1fr)); gap: 1rem;">';
                                        
                                        html += `<div style="padding: 0.75rem; background: rgba(255,255,255,0.05); border-radius: 6px;">
                                            <div style="font-size: 0.75rem; color: #94a3b8; text-transform: uppercase; letter-spacing: 0.5px;">Valid Words</div>
                                            <div style="font-size: 1.5rem; font-weight: bold; color: #10b981; margin-top: 0.25rem;">${metrics.validWords} / ${metrics.totalWords}</div>
                                            <div style="font-size: 0.8rem; color: #64748b; margin-top: 0.25rem;">${metrics.wordCoverage}% coverage</div>
                                        </div>`;
                                        
                                        html += `<div style="padding: 0.75rem; background: rgba(255,255,255,0.05); border-radius: 6px;">
                                            <div style="font-size: 0.75rem; color: #94a3b8; text-transform: uppercase; letter-spacing: 0.5px;">Character Coverage</div>
                                            <div style="font-size: 1.5rem; font-weight: bold; color: #3b82f6; margin-top: 0.25rem;">${metrics.charCoverage}%</div>
                                            <div style="font-size: 0.8rem; color: #64748b; margin-top: 0.25rem;">${metrics.validChars} / ${metrics.totalChars} chars</div>
                                        </div>`;
                                        
                                        html += `<div style="padding: 0.75rem; background: rgba(255,255,255,0.05); border-radius: 6px;">
                                            <div style="font-size: 0.75rem; color: #94a3b8; text-transform: uppercase; letter-spacing: 0.5px;">Avg Word Length</div>
                                            <div style="font-size: 1.5rem; font-weight: bold; color: #8b5cf6; margin-top: 0.25rem;">${metrics.avgWordLength}</div>
                                            <div style="font-size: 0.8rem; color: #64748b; margin-top: 0.25rem;">letters per word</div>
                                        </div>`;
                                        
                                        const dictConfidencePercent = (validation.confidence * 100).toFixed(0);
                                        const dictConfidenceColor = validation.confidence > 0.7 ? '#10b981' : validation.confidence > 0.4 ? '#f59e0b' : '#ef4444';
                                        html += `<div style="padding: 0.75rem; background: rgba(255,255,255,0.05); border-radius: 6px;">
                                            <div style="font-size: 0.75rem; color: #94a3b8; text-transform: uppercase; letter-spacing: 0.5px;">Dictionary Score</div>
                                            <div style="font-size: 1.5rem; font-weight: bold; color: ${dictConfidenceColor}; margin-top: 0.25rem;">${dictConfidencePercent}%</div>
                                            <div style="font-size: 0.8rem; color: #64748b; margin-top: 0.25rem;">confidence</div>
                                        </div>`;
                                        
                                        html += '</div>';
                                        
                                        if (validation.foundWords && validation.foundWords.length > 0) {
                                            html += `<div style="margin-top: 1rem; padding: 0.75rem; background: rgba(255,255,255,0.03); border-radius: 6px;">
                                                <div style="font-size: 0.75rem; color: #94a3b8; text-transform: uppercase; letter-spacing: 0.5px; margin-bottom: 0.5rem;">Sample Valid Words</div>
                                                <div style="display: flex; flex-wrap: wrap; gap: 0.5rem;">
                                                    ${validation.foundWords.map(word => `<span style="padding: 4px 8px; background: rgba(16, 185, 129, 0.2); color: #10b981; border-radius: 4px; font-size: 0.85rem; font-family: monospace;">${word}</span>`).join('')}
                                                </div>
                                            </div>`;
                                        }
                                        
                                        dictValidationContent.innerHTML = html;
                                        dictValidationContainer.style.display = 'block';
                                    } else {
                                        dictValidationContainer.style.display = 'none';
                                    }
                                } catch (validationError) {
                                    console.error('[Demo] Manual validation failed:', validationError);
                                    dictValidationContainer.style.display = 'none';
                                }
                            } else {
                                dictValidationContainer.style.display = 'none';
                            }
                        }
                        
                        container.scrollIntoView({ behavior: 'smooth' });
                        
                        // Mark as successful
                        lastDecryptionSuccess = true;

                    } catch (e) {
                        console.error(e);
                        alert("Error: " + e.message);
                        output.innerText = "‚ùå Decryption failed. The cipher may be too complex or the text too short.";
                        lastDecryptionSuccess = false;
                    } finally {
                        updateButtonState();
                    }
                }, 100);
            });
        });
    </script>
</body>
</html>

